<!DOCTYPE html>
<html lang='en' class='notranslate' translate='no'>
    <head>
      <meta name='google' content='notranslate' />
      <meta charset='UTF-8'>
      <meta name='viewport' content='width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no' />
      <meta name="author" content="Charmaine Chui" />
      <meta name="description" content="A GIS web application to showcase transportating routing in Singapore.">
      <meta name="subject" content="Transportation Routing in Singapore" />
      <meta name="keywords" content="data analytics, geospatial analytics, gis, route optimisation, transportation api, web application, programmer" />
      <meta http-equiv='X-UA-Compatible' content='IE=Edge,chrome=1' />  
      <meta http-equiv='Content-Language' content='en' />
      <link rel='shortcut icon' href='img/favicon.ico'>
      <meta name='msapplication-TileColor' content='#ffffff' />
      <meta name='theme-color' content='#ffffff' />
      <meta name='apple-mobile-web-app-status-bar-style' content='black-translucent' />
      <meta name='apple-mobile-web-app-capable' content='yes' />
      <meta name='mobile-web-app-capable' content='yes' />
      <meta name='HandheldFriendly' content='True' />
      <meta name='MobileOptimized' content='320' />  
      <meta http-equiv='Content-Security-Policy' content='upgrade-insecure-requests' /> 
      <link href='css/bootstrap-4.5.2.min.css' rel='stylesheet' type='text/css' />
      <link href='css/offcanvas.css' rel='stylesheet' type='text/css' />
      <link rel="stylesheet" href="css/leaflet-1.3.1.css" />
      <link rel="stylesheet" href="css/custom.css" />
      <title>SG Transportation Routing</title>
      <noscript>You need to enable JavaScript to run this app.</noscript> 
  </head>
  <body>
      <div class='container-full'>
        <nav id='top-bar' class='navbar navbar-expand-sm bg-light navbar-light'>
            <ul class='navbar-nav w-100'>
              <li class='nav-item ml-0 mr-2'>üïπ <span><kbd>L</kbd>‚¨å<kbd>R</kbd></span></li>
              <li class='nav-item ml-1 mr-0 w-25'>
                <form onsubmit='return!1' class='pure-form'>
                    <div class="input-group input-group-sm">
                        <div class="input-group-prepend">
                          <span class="input-group-text rounded-0"><img src='img/origin.png' alt='origin marker' style='height: 1rem' /></span>
                        </div>
                        <input id='geocoder_o' type='text' class='form-control rounded-0' name='geocoder_o' placeholder='Search Origin...' />
                    </div>
                </form>
              </li>
              <li class='nav-item ml-1 mr-1'><strong id='switch_origin_destination' class='btn btn-sm btn-outline-dark border rounded-circle'>‚áã</strong></li>
              <li class='nav-item ml-0 mr-1 w-25'>
                <form onsubmit='return!1' class='pure-form'>
                   <div class="input-group input-group-sm">
                      <div class="input-group-prepend">
                        <span class="input-group-text rounded-0"><img src='img/destination.png' alt='destination marker' style='height: 1rem' /></span>
                      </div>
                      <input id='geocoder_d' type='text' class='form-control rounded-0' name='geocoder_d' placeholder='Search Destination...' />
                  </div>
                </form>
              </li>
              <li class='nav-item ml-1 mr-1'>
                <div class="form-check-inline">
                    <label class="form-check-label mr-2 ml-0">
                        <span><input type="radio" class="form-check-input routeType" name="routeType" value="0" checked />üöó</span>
                    </label>
                    <label class="form-check-label mr-2 ml-0">
                        <span><input type="radio" class="form-check-input routeType" name="routeType" value="1" />üë£</span>
                    </label>
                    <label class="form-check-label mr-2 ml-0">
                        <span><input type="radio" class="form-check-input routeType" name="routeType" value="2" />üö≤</span>
                    </label>
                </div>
              </li>
              <li class='nav-item ml-1 mr-1'>
                <div class='form-check-inline'>

                  <label class='form-check-label mr-2 ml-0'>
                    <input type='radio' class='form-check-input serviceProvider' name='serviceProvider' value='OneMap' checked /><svg class='selection-side-icon icon icon-onemap'><use xlink:href='symbol-defs.svg#icon-onemap'></use></svg>
                  </label>

                  <label class='form-check-label mr-2 ml-0'>
                    <input type='radio' class='form-check-input serviceProvider' name='serviceProvider' value='Graphhopper' /><svg class='selection-side-icon icon icon-graphhoper'><use xlink:href='symbol-defs.svg#icon-graphhoper'></use></svg>
                  </label>

                  <label class='form-check-label mr-2 ml-0'>
                    <input type='radio' class='form-check-input serviceProvider' name='serviceProvider' value='HERE' /><svg class='selection-side-icon icon icon-here'><use xlink:href='symbol-defs.svg#icon-here'></use></svg>
                  </label>
                 </div>
              </li>
              <li class='nav-item ml-1 mr-1'><button id='resetMapBtn' class='btn btn-sm btn-outline-danger rounded-circle'><b>‚≠Æ</b></button></li>
              <li class='nav-item ml-1 mr-1'>
                <button type='button' class='btn btn-sm btn-outline-info rounded-circle' data-toggle="popover" data-title="üèÖ Acknowledgement & Credits" data-dismissible="true" data-placement="right" data-content="
                  <small class='text-muted'>
                    <dl>
                      <dt>‚ù∂ Routing APIs</dt>
                      <dd class='pl-3'>
                        <svg class='selection-side-icon icon icon-onemap'><use xlink:href='symbol-defs.svg#icon-onemap'></use></svg> <a href='https://www.onemap.gov.sg/docs/#onemap-rest-apis' target='_blank'>OneMap Rest APIs</a>, by <a href='http://SLA.gov.sg' target='_blank'><abbr title='Singapore Land Authority'>SLA</abbr></a>
                      </dd>
                      <dd class='pl-3'>
                        <svg class='selection-side-icon icon icon-graphhoper'><use xlink:href='symbol-defs.svg#icon-graphhoper'></use></svg> <a href='https://graphhopper.com/maps/' target='_blank'>The Graphhopper Directions API</a>
                      </dd>
                      <dd class='pl-3'>
                        <svg class='selection-side-icon icon icon-here'><use xlink:href='symbol-defs.svg#icon-here'></use></svg> <a href='https://www.here.com/platform/routing' target='_blank'>HERE Routing API</a>
                      </dd>

                      <dt>‚ù∑ Geocoding APIs</dt>
                      <dd class='pl-3'>
                        <svg class='selection-side-icon icon icon-opencage'><use xlink:href='symbol-defs.svg#icon-opencage'></use></svg> <a href='https://opencagedata.com/credits' target='_blank'>OpenCage Geocoding API</a>
                      </dd>
                      <dd class='pl-3'>
                         <svg class='selection-side-icon icon icon-onemap'><use xlink:href='symbol-defs.svg#icon-onemap'></use></svg> <a href='https://www.onemap.gov.sg/docs/#onemap-rest-apis' target='_blank'>OneMap Rest APIs</a>, by <a href='http://SLA.gov.sg' target='_blank'><abbr title='Singapore Land Authority'>SLA</abbr></a>
                      </dd>

                      <dt>‚ù∏ JavaScript Map Plugin</dt>
                      <dd class='pl-3'>
                        <svg class='selection-side-icon icon icon-leaflet'><use xlink:href='symbol-defs.svg#icon-leaflet'></use></svg> Powered by <a href='https://leafletjs.com/SlavaUkraini/reference.html' target='_blank'> Leaflet</a>
                      </dd>

                      <dt>‚ùπ Basemap</dt>
                      <dd class='pl-3'>
                        üó∫ <a href='https://carto.com/attributions' target='_blank'> CARTO</a>, by <a href='http://www.openstreetmap.org/copyright' target='_blank'>OpenStreetMap</a>
                      </dd>

                    </dl>
                  </small>"
                ><small>üèÖ</small>
                </button>
              </li>
              <button id='loaderSignal' class='btn btn-sm btn-light p-0' disabled><span class='spinner-border spinner-border-sm m-1'></span><small>Loading..</small></button>
            </ul>
        </nav>
        <div id='map'></div>
      </div>
      <script type='text/javascript' src='js/autocomplete.js'></script>
      <script type='text/javascript' src='js/geocoders.js'></script>
      <script type='text/javascript' src='js/polyfill.js'></script>
      <script type='text/javascript' src='js/ie10-viewport-bug-workaround.js'></script>
      <script type='text/javascript' src='js/bootstrap-native-v4.js'></script>
      <script type='text/javascript' src='js/leaflet-1.3.1.js'></script>
      <script type='text/javascript' src='js/L.Polyline.SnakeAnim.js'></script>
      <script type='text/javascript' src='js/polyline.js'></script>
      <script type='text/javascript' src='js/flexi-polyline.js'></script>
      <script type='text/javascript' src='js/svgxuse.js' defer></script>
      <script type='text/javascript' src='js/utils.js'></script>
      <script type='text/javascript' src='js/articulate.js'></script>
      <script type='text/javascript' src='js/initLeafletMap.js'></script>
      <script>
        var loaderSignal=document.getElementById('loaderSignal');
        loaderSignal['style']['display']='none';

        var initStartPoint='1.30607515954354,103.831003321455';
        var initEndPoint='1.3249477928719,103.805704361472';

        var initStartAddr='CLAYMORE HILL';
        var initEndAddr='DUCHESS ROAD';

        var startPoint=initStartPoint;
        var endPoint=initEndPoint;

        geocoder_o.value=initStartAddr;
        geocoder_d.value=initEndAddr;

        var routes=[];
        
        const iconSize=[25, 25];

        var originMarker=null; 
        var destinationMarker=null; 
        var originName=null;
        var destinationName=null;
        var snakingSpeed=400; // pixels per second

        var serviceProvider='OneMap';
        var url = '';
        var apiCall = '';
        var params = {};

        command.onAdd = function(map) {
          let div = L.DomUtil.create('div', 'command');

          let htmlStr = '';
          htmlStr += '<div class="leaflet-control-layers leaflet-control leaflet-control-layers-expanded">';

          htmlStr += '<section class="leaflet-control-layers-list">';
          htmlStr += '<div class="leaflet-control-layers-base">';
          htmlStr += '<div class="leaflet-control-layers-overlays">';

          htmlStr += "<b class='pl-2 mb-2 mt-2'><span class='mr-1'>‚Ñπ</span>Route Options</b>";
          htmlStr += "<div id='route_options'></div>";
          htmlStr += "<hr class='border-0'>";
          htmlStr += "<div id='route_info'></div>";
          htmlStr += "<hr class='border-0'>";

          htmlStr += "<div id='mainTabsWrapper' class='card rounded-0 border-0'>";

          htmlStr += "<ul id='mainTabs' class='nav nav-tabs' role='tablist'>";

          htmlStr += "<li class='nav-item'><a class='nav-link rounded-0 active' id='route_instructions-tab' href='#route_instructions' data-bs-toggle='tab' data-height='true' aria-controls='route_instructions' aria-selected='true' role='tab'>";
          htmlStr += '‚õñ Route Instructions';
          htmlStr += '</a></li>';

          htmlStr += "<li class='nav-item'><a class='nav-link rounded-0' id='geojson-tab' href='#geojson' data-bs-toggle='tab' data-height='true' aria-controls='geojson' aria-selected='true' role='tab'>";
          htmlStr += '‚ùÆ‚ÅÑ‚ùØ Export GeoJSON Data';
          htmlStr += '</a></li>';

          htmlStr += '<li class="nav-item ml-1">';
          htmlStr += '<button id="speakBtn" class="btn btn-sm btn-outline-dark border rounded-circle">üîä</button>';
          htmlStr += '</li>';

          htmlStr += '<li class="nav-item mr-1 ml-1">';
          htmlStr += '<button id="exportBtn" class="btn btn-sm btn-outline-dark border rounded-circle"><small>üì•</small></button>';
          htmlStr += '</li>';

          htmlStr += '</ul>';

          htmlStr += "<div class='card-body tab-content'>";
          htmlStr += "<div id='route_instructions' role='tabpanel' class='tab-pane fade active show' aria-labelledby='route_instructions-tab'></div>";
          htmlStr += "<div id='geojson' role='tabpanel' class='tab-pane fade' aria-labelledby='geojson-tab'></div>";
          htmlStr += "</div>";

          htmlStr += "</div>";

          htmlStr += "</div>";
          htmlStr += "</div>";
          htmlStr += "</section>";

          htmlStr += "</div>";

          (async() => {
            await div.insertAdjacentHTML('beforeend', htmlStr); 

            document.getElementById('exportBtn').addEventListener('click', () => {
              if (!window.Blob) {
                alert('Your browser does not support HTML5 "Blob" function required to save a file.');
              } else {
                let textblob = new Blob([document.getElementById('geojson').innerText], {
                    type: 'application/json'
                });
                let dwnlnk = document.createElement('a');
                dwnlnk.download = 'georoutes.json';
                dwnlnk.innerHTML = 'Download File';
                if (window.webkitURL != null) {
                    dwnlnk.href = window.webkitURL.createObjectURL(textblob);
                }
                dwnlnk.click();
              }
            }, false);

            const playSymbol='üîä';
            const pauseSymbol='üîá';

            document.getElementById('speakBtn').addEventListener('click', (evt) => {
              let isPaused=$().articulate('isPaused');
              let isSpeaking=$().articulate('isSpeaking');

              if(!isPaused && !isSpeaking) {
                $('#route_instructions td').articulate('speak');
                evt.currentTarget.innerHTML=pauseSymbol;
              } else if(!isPaused) {
                $().articulate('pause');
                evt.currentTarget.innerHTML=playSymbol;
              } else if(isPaused) {
                $().articulate('resume');
                evt.currentTarget.innerHTML=pauseSymbol;
              }
            }, false);

            window.addEventListener('utteranceHasEnded', (e) => {
              document.getElementById('speakBtn').innerHTML=playSymbol;
              $().articulate('stop');
            }, false);
          })();

          return div;
        };

        var routeTypes=[
          { 
            'OneMap': 'drive', 
            'Graphhopper': 'car',
            'HERE': 'car'
          },

          { 
            'OneMap': 'walk',
            'Graphhopper': 'foot',
            'HERE': 'pedestrian' 
          },
          { 
            'OneMap': 'cycle', 
            'Graphhopper': 'bike',
            'HERE': 'bicycle'
          }
        ];

        var routeType=0;

        window.onload=function() {
          var mainTabs = document.getElementById('mainTabs');
          var mainTabsCollection = mainTabs.getElementsByTagName('a');
          Array.from(mainTabsCollection).forEach(tab => new BSN.Tab(tab));

          var popoverTargets = document.querySelectorAll('[data-content]');

          Array.from(popoverTargets).map(
            popTarget => new BSN.Popover(popTarget, {
              placement: 'right',
              animation: 'show',
              delay: 100,
              dismissible: true,
              trigger: 'click'
            })
          );

          function getCurrentDatetimeStamp() {
            const d = new Date();
            var datestamp=d.getFullYear()+''+(d.getMonth()+1)+''+d.getDate();
            var timestamp=d.getHours()+''+d.getMinutes()+''+d.getSeconds();

            var datetimeStr=datestamp+'_'+timestamp;
            return datetimeStr;
          }

          document.getElementById('switch_origin_destination').addEventListener('click', (e) => {
            let tempPoint=endPoint;
            endPoint=startPoint;
            startPoint=tempPoint;

            initParams(startPoint, endPoint);
            execAjax();
          }, false);

          var resetMapBtn=document.getElementById('resetMapBtn');
          var serviceProviderOptions=document.getElementsByClassName('serviceProvider');

          for(var serviceProviderOption of serviceProviderOptions) {
            serviceProviderOption.addEventListener('change', (e) => {
              serviceProvider=e.target.value;
              initParams(startPoint, endPoint);
              execAjax();
            }, false);
          }

          function removeAllRoutes() {
            if(routes.length>0) { 
              for(var r in routes) {
                  var path=routes[r]["path"];
                  map.removeLayer(path);
              }
            }
          }

          function removeAllMarkers() {
            if(originMarker!==null) {
                map.removeLayer(originMarker);
            }
            if(destinationMarker!==null) {
                map.removeLayer(destinationMarker);
            }
          }
          
          function resetMap() {
            removeAllRoutes();
            routes=[];
            removeAllMarkers();

            document.getElementById('route_options').innerHTML='';
            document.getElementById('route_info').innerHTML='';
            document.getElementById('route_instructions').innerHTML='';
            document.getElementById('geojson').innerHTML='';
          }

          resetMapBtn.addEventListener('click', (evt) => {
            resetMap();

            loaderSignal['style']['display']='none';

            startPoint=initStartPoint;
            endPoint=initEndPoint;

            geocoder_o.value=initStartAddr;
            geocoder_d.value=initEndAddr;

            serviceProvider='OneMap';
            for(var serviceProviderOption of serviceProviderOptions) {
              if(serviceProviderOption.value==serviceProvider) {
                serviceProviderOption.click();
                break;
              }
            }
            initParams(startPoint, endPoint);
            execAjax();
          }, false);

          function initParams(start, end) {
            resetMap();
            switch(serviceProvider) {
              case 'OneMap':
                url='/api/onemap/directions/json/';
                params = {
                  'routeType':routeTypes[routeType][serviceProvider],
                  'start': start,
                  'end':end
                };
                break;
              case 'Graphhopper':
                url='api/graphhopper/route/json/';
                start=start.split(',');
                start=parseFloat(start[0]).toFixed(4) + '%2C' + parseFloat(start[1]).toFixed(4);

                end=end.split(',');
                end=parseFloat(end[0]).toFixed(4) + '%2C' + parseFloat(end[1]).toFixed(4);
                params = {
                  'locale':'en',
                  'point_o':start,
                  'point_d':end,
                  'elevation': (routeType==0) ? 'false' : 'true',
                  'profile':routeTypes[routeType][serviceProvider]
                };
                break;
              case 'HERE':
                url='api/hereapi/v8/route/json/';
                params = {
                  'origin': start,
                  'destination':end,
                  'routeType':routeTypes[routeType][serviceProvider]
                };
                break;
            }
            apiCall = '';
            apiCall+=url;
            for(let p in params) {
              apiCall+=params[p]+'/';
            }
          }

          var geocoder_o=document.getElementById('geocoder_o');
          var geocoder_d=document.getElementById('geocoder_d');

          var o_geocoder=new autoComplete({
            selector:'#geocoder_o',
            minChars:2,
            source: function(term, suggest){
              term = term.toLowerCase();
              var choices = Object.keys(geocoders);
              var suggestions = [];
              for (var i=0;i<choices.length;i++) {
                  if (~choices[i].toLowerCase().indexOf(term)) {
                    suggestions.push(choices[i]);
                  }
              }
              suggest(suggestions);
            },
            onSelect: function(e, term, item) {
              let coordinatesStr=geocoders[term];
              startPoint=coordinatesStr;
              initParams(startPoint, endPoint);
              execAjax();
            }
          });

          var d_geocoder=new autoComplete({
            selector:'#geocoder_d',
            minChars:2,
            source: function(term, suggest){
              term = term.toLowerCase();
              var choices = Object.keys(geocoders);
              var suggestions = [];
              for (var i=0;i<choices.length;i++) {
                  if (~choices[i].toLowerCase().indexOf(term)) {
                    suggestions.push(choices[i]);
                  }
              }
              suggest(suggestions);
            },
            onSelect: function(e, term, item) {
              let coordinatesStr=geocoders[term];
              endPoint=coordinatesStr;
              initParams(startPoint, endPoint);
              execAjax();
            }
          });

          function renderHERERoutesOnMap(responseObj) {
            let sections=responseObj['routes'][0]['sections'][0];
            let polyline=sections['polyline'];
            let latlngs_1 = decodeFlexiPolyline(polyline).polyline;
            
            map.fitBounds(L.latLngBounds(latlngs_1));
            originMarker=L.marker(latlngs_1[0], {
                icon: L.icon({      
                    iconUrl: 'img/origin.png',
                    iconSize: iconSize
                })
            });
            map.addLayer(originMarker);

            destinationMarker=L.marker(latlngs_1[latlngs_1.length - 1], {
                icon: L.icon({ 
                    iconUrl: 'img/destination.png',
                    iconSize: iconSize
                })
            });
            map.addLayer(destinationMarker);

            let path_1 = L.polyline(latlngs_1, {
                snakingSpeed: snakingSpeed,
                className: 'route',
                color: generateRandomColor()
            });
            map.addLayer(path_1);
            path_1.snakeIn();

            let route_1 = {
                path: path_1
            };
            routes.push(route_1);
          }

          function renderOneMapRoutesOnMap(responseObj) {
            let latlngs_1 = polyline.decode(responseObj['route_geometry']);
            map.fitBounds(L.latLngBounds(latlngs_1));
            originMarker=L.marker(latlngs_1[0], {
                icon: L.icon({      
                    iconUrl: 'img/origin.png',
                    iconSize: iconSize
                })
            });
            map.addLayer(originMarker);

            destinationMarker=L.marker(latlngs_1[latlngs_1.length - 1], {
                icon: L.icon({ 
                    iconUrl: 'img/destination.png',
                    iconSize: iconSize
                })
            });
            map.addLayer(destinationMarker);

            let path_1 = L.polyline(latlngs_1, {
                snakingSpeed: snakingSpeed,
                className: 'route',
                color: generateRandomColor()
            });
            map.addLayer(path_1);
            path_1.snakeIn();

            let route_1 = {
                path: path_1
            };
            routes.push(route_1);
            
            let phyroute=responseObj['phyroute'];
            if(typeof phyroute !== 'undefined') {
              let latlngs_2 = polyline.decode(phyroute['route_geometry']);

              let path_2 = L.polyline(latlngs_2, {
                snakingSpeed: snakingSpeed,
                className: 'route',
                color: generateRandomColor()
              });

              let route_2 = { path: path_2 };
              routes.push(route_2);
            }

            let alternativeroute=responseObj['alternativeroute'];
            if(typeof alternativeroute !== 'undefined') {
              alternativeroute=alternativeroute[0];
              let latlngs_3 = polyline.decode(alternativeroute['route_geometry']);

              let path_3 = L.polyline(latlngs_3, {
                snakingSpeed: snakingSpeed,
                className: 'route',
                color: generateRandomColor()
              });

              let route_3 = {
                path: path_3
              };
              routes.push(route_3);
            }
          }

          function renderGraphhopperRoutesOnMap(responseObj) {
            let points=responseObj['paths'][0]['points'];

            let paths=responseObj["paths"][0];
            let latlngs_1 = polyline.decode(points);
            
            map.fitBounds(L.latLngBounds(latlngs_1));
            originMarker=L.marker(latlngs_1[0], {
                icon: L.icon({      
                    iconUrl: 'img/origin.png',
                    iconSize: iconSize
                })
            });
            map.addLayer(originMarker);

            destinationMarker=L.marker(latlngs_1[latlngs_1.length - 1], {
                icon: L.icon({ 
                    iconUrl: 'img/destination.png',
                    iconSize: iconSize
                })
            });
            map.addLayer(destinationMarker);

            let path_1 = L.polyline(latlngs_1, {
                snakingSpeed: snakingSpeed,
                className: 'route',
                color: generateRandomColor()
            });
            map.addLayer(path_1);
            path_1.snakeIn();

            let route_1 = {
                path: path_1
            };
            routes.push(route_1);
          }

          async function geocodeLatlng(lat,lng) {
            loaderSignal['style']['display']='inline-flex';
            let response=await fetch(`api/opencage/geocode/json/v1/en/${lat}+${lng}`);
            let responseObj=await response.json();
            loaderSignal['style']['display']='none';
            return new Promise((resolve) => resolve(responseObj));
          }

          async function execAjax() {
            loaderSignal['style']['display']='inline-flex';
            let response=await fetch(apiCall);
            let result=await response.text();
            let responseObj=JSON.parse(result);
            loaderSignal['style']['display']='none';

            switch(serviceProvider) {
              case 'OneMap':
                renderOneMapRoutesOnMap(responseObj);
                renderOneMapGeojson(responseObj);
                renderOneMapRouteInstructions(responseObj);
                break;
              case 'Graphhopper':
                renderGraphhopperRoutesOnMap(responseObj);
                renderGraphhoperGeojson(responseObj);
                renderGraphhoperRouteInstructions(responseObj);
                break;
              case 'HERE':
                renderHERERoutesOnMap(responseObj);
                renderHEREGeojson(responseObj);
                renderHERERouteInstructions(responseObj);
                break;
            }
          }

          function handleCommand() {
            // console.log(routes);
            removeAllRoutes();

            let routeIndex = parseInt(this.value);
            let routeObj = routes[routeIndex];

            let name=routeObj["name"];
            let start_point=routeObj["start_point"];
            let end_point=routeObj["end_point"];
            let description=routeObj["description"];
            let time_seconds=routeObj["time_seconds"];
            let distance_metres=routeObj["distance_metres"];
            let route_instructions=routeObj["route_instructions"];
            let path=routeObj["path"];

            // render route on map
            map.addLayer(path);
            path.snakeIn();

            originName=routeObj["start_point"];
            destinationName=routeObj["end_point"];

            geocoder_o.value=originName;
            geocoder_d.value=destinationName;

            let routeInfo = "";
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>Route Type:</b> ' + routeTypes[routeType][serviceProvider] + '</label>';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>From:</b> ' + start_point + ' <img src="img/origin.png" class="selection-side-icon" /></label>';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>To:</b> ' + end_point + ' <img src="img/destination.png" class="selection-side-icon" /></label>';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>Total Distance:</b> ' + parseFloat(distance_metres/1000).toFixed(2) + ' km</label>';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>Total Time:</b> ' + parseInt(time_seconds/60) + ' min ' + routeObj["time_seconds"]%60 + ' s</label>';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>Description:</b> ' + name + '</label>';

            document.getElementById("route_info").innerHTML=routeInfo;
            document.getElementById("route_instructions").innerHTML=route_instructions;
          }

          async function renderOneMapGeojson(responseObj) {
            let routeCounter=0;
            let geojsonOutput={
              "type": "FeatureCollection",
              "features": []
            };
            let geometry=polyline.toGeoJSON(responseObj["route_geometry"]);

            let name = responseObj["route_name"][0] + " via " + responseObj["viaRoute"] + " through " + responseObj["route_name"][1];
            let description = responseObj["subtitle"];
            let start_point = responseObj["route_summary"]["start_point"];
            let end_point = responseObj["route_summary"]["end_point"];
            let time_seconds = responseObj["route_summary"]["total_time"];
            let distance_metres = responseObj["route_summary"]["total_distance"];

            let route_instructions=responseObj['route_instructions'];

            let startLatLng=route_instructions[0][3];
            if(start_point.length===0) {
              let start_point_arr=startLatLng.split(',');
              let obj=await geocodeLatlng(start_point_arr[0],start_point_arr[1]);
              start_point=obj['results'][0]['formatted'];
            }

            let endLatLng=route_instructions[route_instructions.length-1][3];
            if(end_point.length===0) {
              let end_point_arr=endLatLng.split(',');
              let obj=await geocodeLatlng(end_point_arr[0],end_point_arr[1]);
              end_point=obj['results'][0]['formatted'];
            }

            if(routeType==2) { // cycle
              name="Cycling Path";
              description="Cycling Path";
            } else if(routeType==1) { // walking
              name="Walking Path";
              description="Walking Path";
            } // end of walking path

            let feature={
              "type": "Feature",
              "geometry": geometry,
              "properties": {
                  "name": name,
                  "description": description,
                  "start_point": start_point,
                  "end_point": end_point,
                  "time_seconds": time_seconds,
                  "distance_metres": distance_metres,
                  "route_type": routeTypes[routeType][serviceProvider]
              }
            };
            geojsonOutput["features"].push(feature);

            let controlHtmlStr = '';
            controlHtmlStr += '<label class="form-check-label mr-3 ml-3">';
            controlHtmlStr += '<div>';
            controlHtmlStr += '<input id="' + name + '" type="radio" class="leaflet-control-layers-selector" name="routes" checked="checked" value="'+routeCounter+'" />';
            controlHtmlStr += '<span> ' + description + '</span>';
            controlHtmlStr += '</div>';
            controlHtmlStr += '</label>';
            
            // console.log(routeCounter);
            routes[routeCounter]["name"]=name;
            routes[routeCounter]["description"]=description;
            routes[routeCounter]["start_point"]=start_point;
            routes[routeCounter]["end_point"]=end_point;
            routes[routeCounter]["time_seconds"]=time_seconds;
            routes[routeCounter]["distance_metres"]=distance_metres;
            routeCounter++;

            originName=start_point;
            destinationName=end_point;

            geocoder_o.value=originName;
            geocoder_d.value=destinationName;

            let routeInfo = '';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>Route Type:</b> ' + routeTypes[routeType][serviceProvider] + '</label>';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>From:</b> ' + start_point + ' <img src="img/origin.png" class="selection-side-icon" /></label>';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>To:</b> ' + end_point + ' <img src="img/destination.png" class="selection-side-icon" /></label>';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>Total Distance:</b> ' + parseFloat(distance_metres/1000).toFixed(2) + ' km</label>';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>Total Time:</b> ' + parseInt(time_seconds/60) + ' min ' + time_seconds%60 + ' s</label>';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>Description:</b> ' + description + '</label>';

            document.getElementById("route_info").innerHTML=routeInfo;
            
            let phyroute=responseObj["phyroute"];
            if(typeof phyroute !== "undefined") {
              geometry = polyline.toGeoJSON(phyroute["route_geometry"]);   

              name = phyroute["route_name"][0] + " via " + phyroute["viaRoute"] + " through " + phyroute["route_name"][1];
              description = phyroute["subtitle"];
              start_point = phyroute["route_summary"]["start_point"];
              end_point = phyroute["route_summary"]["end_point"];
              time_seconds = phyroute["route_summary"]["total_time"];
              distance_metres = phyroute["route_summary"]["total_distance"];

              feature={
                "type": "Feature",
                "geometry": geometry,
                "properties": {
                    "name": name,
                    "description": description,
                    "start_point": start_point,
                    "end_point": end_point,
                    "time_seconds": time_seconds,
                    "distance_metres": distance_metres,
                    "route_type": routeTypes[routeType][serviceProvider]
                }
              };
              geojsonOutput["features"].push(feature);
              
              controlHtmlStr += '<label class="form-check-label mr-3 ml-3">';
              controlHtmlStr += "<div>";
              controlHtmlStr += "<input id='" + name + "' type='radio' class='leaflet-control-layers-selector' name='routes' value='"+(routeCounter)+"' />";
              controlHtmlStr += "<span> " + description + "</span>";
              controlHtmlStr += "</div>";
              controlHtmlStr += "</label>";

              // console.log(routeCounter);
              routes[routeCounter]["name"]=name;
              routes[routeCounter]["description"]=description;
              routes[routeCounter]["start_point"]=start_point;
              routes[routeCounter]["end_point"]=end_point;
              routes[routeCounter]["time_seconds"]=time_seconds;
              routes[routeCounter]["distance_metres"]=distance_metres;
              routeCounter++;
            }

            let alternativeroute=responseObj["alternativeroute"];

            if(typeof alternativeroute !== "undefined") {
              alternativeroute=alternativeroute[0];
              geometry = polyline.toGeoJSON(alternativeroute["route_geometry"]);   

              name = alternativeroute["route_name"][0] + " via " + alternativeroute["viaRoute"] + " through " + alternativeroute["route_name"][1];
              description = alternativeroute["subtitle"];
              start_point = alternativeroute["route_summary"]["start_point"];
              end_point = alternativeroute["route_summary"]["end_point"];
              time_seconds = alternativeroute["route_summary"]["total_time"];
              distance_metres = alternativeroute["route_summary"]["total_distance"];

              feature={
                "type": "Feature",
                "geometry": geometry,
                "properties": {
                    "name": name,
                    "description": description,
                    "start_point": start_point,
                    "end_point": end_point,
                    "time_seconds": time_seconds,
                    "distance_metres": distance_metres,
                    "route_type": routeTypes[routeType][serviceProvider]
                }
              };
              geojsonOutput["features"].push(feature);

              controlHtmlStr += '<label class="form-check-label mr-3 ml-3">';
              controlHtmlStr += "<div>";
              controlHtmlStr += "<input id='" + name + "' type='radio' class='leaflet-control-layers-selector' name='routes' value='"+(routeCounter)+"' />";
              controlHtmlStr += "<span> " + description + "</span>";
              controlHtmlStr += "</div>";
              controlHtmlStr += "</label>";

              // console.log(routeCounter);
              routes[routeCounter]["name"]=name;
              routes[routeCounter]["description"]=description;
              routes[routeCounter]["start_point"]=start_point;
              routes[routeCounter]["end_point"]=end_point;
              routes[routeCounter]["time_seconds"]=time_seconds;
              routes[routeCounter]["distance_metres"]=distance_metres;
              routeCounter++;
            }

            document.getElementById("route_options").innerHTML=controlHtmlStr;
            document.getElementById("geojson").appendChild(document.createElement("pre")).innerHTML = syntaxHighlight(JSON.stringify(geojsonOutput, undefined, 2));

            let commands = document.getElementsByClassName("leaflet-control-layers-selector");
            for(let c in commands) {
              let cmd = commands[c];
              if(cmd.type == "radio") {
                cmd.addEventListener("change", handleCommand, false);
              }
            }
          } // renderOneMapGeojson

          async function renderGraphhoperGeojson(responseObj) {
            let paths=responseObj["paths"][0];
            let latlngs = polyline.decode(paths['points']);

            let routeCounter=0;
            let geojsonOutput={
              "type": "FeatureCollection",
              "features": []
            };
            let geometry=polyline.toGeoJSON(paths["points"]);

            let start_point = '';
            let end_point = '';
            let time_seconds = (paths["time"]/1000);
            let distance_metres = paths["distance"];

            let startLatLng=latlngs[0];
            if(start_point.length===0) {
              let start_point_arr=startLatLng;
              let obj=await geocodeLatlng(start_point_arr[0],start_point_arr[1]);
              start_point=obj['results'][0]['components']['road'];
            }

            let endLatLng=latlngs[latlngs.length-1];
            if(end_point.length===0) {
              let end_point_arr=endLatLng;
              let obj=await geocodeLatlng(end_point_arr[0],end_point_arr[1]);
              end_point=obj['results'][0]['components']['road'];
            }

            let name = start_point + " through " + end_point;
            let description = start_point + " through " + end_point;;

            if(routeType==2) { // cycle
              name="Cycling Path";
              description="Cycling Path";
            } else if(routeType==1) { // walking
              name="Walking Path";
              description="Walking Path";
            } // end of walking path

            let feature={
              "type": "Feature",
              "geometry": {
                "type":"LineString",
                "coordinates": latlngs
              },
              "properties": {
                  "name": name,
                  "description": description,
                  "start_point": start_point,
                  "end_point": end_point,
                  "time_seconds": time_seconds,
                  "distance_metres": distance_metres,
                  "route_type": routeTypes[routeType][serviceProvider]
              }
            };
            geojsonOutput["features"].push(feature);

            let controlHtmlStr = '';
            controlHtmlStr += '<label class="form-check-label mr-3 ml-3">';
            controlHtmlStr += '<div>';
            controlHtmlStr += '<input id="' + name + '" type="radio" class="leaflet-control-layers-selector" name="routes" checked="checked" value="'+routeCounter+'" />';
            controlHtmlStr += '<span> ' + description + '</span>';
            controlHtmlStr += '</div>';
            controlHtmlStr += '</label>';
            
            // console.log(routeCounter);
            routes[routeCounter]["name"]=name;
            routes[routeCounter]["description"]=description;
            routes[routeCounter]["start_point"]=start_point;
            routes[routeCounter]["end_point"]=end_point;
            routes[routeCounter]["time_seconds"]=time_seconds;
            routes[routeCounter]["distance_metres"]=distance_metres;
            routeCounter++;

            originName=start_point;
            destinationName=end_point;

            geocoder_o.value=originName;
            geocoder_d.value=destinationName;

            let routeInfo = '';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>Route Type:</b> ' + routeTypes[routeType][serviceProvider] + '</label>';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>From:</b> ' + start_point + ' <img src="img/origin.png" class="selection-side-icon" /></label>';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>To:</b> ' + end_point + ' <img src="img/destination.png" class="selection-side-icon" /></label>';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>Total Distance:</b> ' + parseFloat(distance_metres/1000).toFixed(2) + ' km</label>';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>Total Time:</b> ' + parseInt(time_seconds/60) + ' min ' + parseInt(time_seconds%60) + ' s</label>';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>Description:</b> ' + description + '</label>';

            document.getElementById("route_info").innerHTML=routeInfo;

            document.getElementById("route_options").innerHTML=controlHtmlStr;
            document.getElementById("geojson").appendChild(document.createElement("pre")).innerHTML = syntaxHighlight(JSON.stringify(geojsonOutput, undefined, 2));

            let commands = document.getElementsByClassName("leaflet-control-layers-selector");
            for(let c in commands) {
              let cmd = commands[c];
              if(cmd.type == "radio") {
                cmd.addEventListener("change", handleCommand, false);
              }
            }
          } // renderGraphhoperGeojson

          async function renderHEREGeojson(responseObj) {
            let sections=responseObj['routes'][0]['sections'][0];
            let polyline=sections['polyline'];
            let latlngs = decodeFlexiPolyline(polyline).polyline;

            let routeCounter=0;
            let geojsonOutput={
              "type": "FeatureCollection",
              "features": []
            };
            let start_point = '';
            let end_point = '';
            let time_seconds = (sections["travelSummary"]["duration"]);
            let distance_metres = (sections["travelSummary"]["length"]);

            let startLatLng=latlngs[0];
            if(start_point.length===0) {
              let start_point_arr=startLatLng;
              let obj=await geocodeLatlng(start_point_arr[0],start_point_arr[1]);
              start_point=obj['results'][0]['components']['road'];
            }

            let endLatLng=latlngs[latlngs.length-1];
            if(end_point.length===0) {
              let end_point_arr=endLatLng;
              let obj=await geocodeLatlng(end_point_arr[0],end_point_arr[1]);
              end_point=obj['results'][0]['components']['road'];
            }

            let name = start_point + " through " + end_point;
            let description = start_point + " through " + end_point;;

            if(routeType==2) { // cycle
              name="Cycling Path";
              description="Cycling Path";
            } else if(routeType==1) { // walking
              name="Walking Path";
              description="Walking Path";
            } // end of walking path

            let feature={
              "type": "Feature",
              "geometry": {
                "type": "LineString",
                "coordinates": reverseLatLng(latlngs)
              },
              "properties": {
                  "name": name,
                  "description": description,
                  "start_point": start_point,
                  "end_point": end_point,
                  "time_seconds": time_seconds,
                  "distance_metres": distance_metres,
                  "route_type": routeTypes[routeType][serviceProvider]
              }
            };
            geojsonOutput["features"].push(feature);

            let controlHtmlStr = '';
            controlHtmlStr += '<label class="form-check-label mr-3 ml-3">';
            controlHtmlStr += '<div>';
            controlHtmlStr += '<input id="' + name + '" type="radio" class="leaflet-control-layers-selector" name="routes" checked="checked" value="'+routeCounter+'" />';
            controlHtmlStr += '<span> ' + description + '</span>';
            controlHtmlStr += '</div>';
            controlHtmlStr += '</label>';
            
            routes[routeCounter]["name"]=name;
            routes[routeCounter]["description"]=description;
            routes[routeCounter]["start_point"]=start_point;
            routes[routeCounter]["end_point"]=end_point;
            routes[routeCounter]["time_seconds"]=time_seconds;
            routes[routeCounter]["distance_metres"]=distance_metres;
            routeCounter++;

            originName=start_point;
            destinationName=end_point;

            geocoder_o.value=originName;
            geocoder_d.value=destinationName;

            let routeInfo = '';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>Route Type:</b> ' + routeTypes[routeType][serviceProvider] + '</label>';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>From:</b> ' + start_point + ' <img src="img/origin.png" class="selection-side-icon" /></label>';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>To:</b> ' + end_point + ' <img src="img/destination.png" class="selection-side-icon" /></label>';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>Total Distance:</b> ' + parseFloat(distance_metres/1000).toFixed(2) + ' km</label>';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>Total Time:</b> ' + parseInt(time_seconds/60) + ' min ' + parseInt(time_seconds%60) + ' s</label>';
            routeInfo+='<label class="form-check-label mr-3 ml-3"><b>Description:</b> ' + description + '</label>';

            document.getElementById("route_info").innerHTML=routeInfo;
            document.getElementById("route_options").innerHTML=controlHtmlStr;
            document.getElementById("geojson").appendChild(document.createElement("pre")).innerHTML = syntaxHighlight(JSON.stringify(geojsonOutput, undefined, 2));

            let commands = document.getElementsByClassName("leaflet-control-layers-selector");
            for(let c in commands) {
              let cmd = commands[c];
              if(cmd.type == "radio") {
                cmd.addEventListener("change", handleCommand, false);
              }
            }
          } // renderHEREGeojson

          var routeTypeOptions=document.getElementsByClassName('routeType');
          for(var routeTypeOption of routeTypeOptions) {
            routeTypeOption.addEventListener('change', (e) => {
               routeType=parseInt(e.target.value);
                initParams(startPoint, endPoint);
                execAjax();
            }, false);
          }

          function renderGraphhoperRouteInstructions(responseObj) {
            let routeCounter=0;
            let routeInstructions = '';
            routeInstructions += '<table>';
            let route_instructions=responseObj['paths'][0]['instructions'];

            // let allPoints=responseObj['paths'][0]['points'];
            for(let r in route_instructions) {
              let route = route_instructions[r];
              let routeSeconds=parseInt(route['time']/1000);
              let distance_metres=parseInt(route['distance']);

              // let instruction_points = allPoints.slice(route['interval'][0], route['interval'][1]);
              // routeInstructions+=JSON.stringify(instruction_points);
              routeInstructions+= '<tr>';
              routeInstructions+= '<th valign="top" class="pr-2">' + parseInt(parseInt(r)+1) + '</th>';
              routeInstructions+= '<td>';
              routeInstructions+= `${route['text']}, at ${distance_metres} metres, for ${routeSeconds} seconds.`;
              routeInstructions+= '</td>';
              routeInstructions+= '</tr>';
            }
            routeInstructions+= '</table>';

            routes[routeCounter]['route_instructions']=routeInstructions;
            routeCounter++;

            document.getElementById('route_instructions').innerHTML=routeInstructions;
          }

          function renderOneMapRouteInstructions(responseObj) {
            let routeCounter=0;
            let routeInstructions = '';
            routeInstructions += '<table>';

            let route_instructions=responseObj['route_instructions'];
            for(let r in route_instructions) {
              let route = route_instructions[r];

              routeInstructions+= '<tr>';
              routeInstructions+= '<th valign="top" class="pr-2">' + parseInt(parseInt(r)+1) + '</th>';
              routeInstructions+= '<td>';
              routeInstructions+= `${route[9]}, at ${route[2]} metres, for ${( (parseInt(route[4]/60)>0) ? parseInt(route[4]/60)+' minutes' : (route[4]+' seconds') )}.`;
              routeInstructions+= '</td>';
              routeInstructions+= '</tr>';
            }
            routeInstructions+= '</table>';

            // console.log(routeCounter);
            routes[routeCounter]['route_instructions']=routeInstructions;
            routeCounter++;

            document.getElementById('route_instructions').innerHTML=routeInstructions;
              
            routeInstructions = '';
            routeInstructions += '<table>';
            let phyroute=responseObj['phyroute'];
            if(typeof phyroute !== 'undefined') {
              route_instructions=phyroute['route_instructions'];
            
              for(let r in route_instructions) {
                let route = route_instructions[r];

                routeInstructions+= '<tr>';
                routeInstructions+= '<th valign="top" class="pr-2">' + parseInt(parseInt(r)+1) + '</th>';
                routeInstructions+= '<td>';
                routeInstructions+= `${route[9]}, at ${route[2]} metres, for ${( (parseInt(route[4]/60)>0) ? parseInt(route[4]/60)+' minutes' : (route[4]+' seconds') )}.`;
                routeInstructions+= '</td>';
                routeInstructions+= '</tr>';
              }
              routeInstructions+= '</table>';

              // console.log(routeCounter);
              routes[routeCounter]['route_instructions']=routeInstructions;
              routeCounter++;
            }

            routeInstructions = "";
            routeInstructions += "<table>";
            let alternativeroute=responseObj["alternativeroute"];
            if(typeof alternativeroute !== "undefined") {
              alternativeroute=alternativeroute[0];
              route_instructions=alternativeroute["route_instructions"];
            
              for(let r in route_instructions) {
                let route = route_instructions[r];

                routeInstructions+= "<tr>";
                routeInstructions+= "<th>" + parseInt(parseInt(r)+1) + "</th>";
                routeInstructions+= "<td>";

                routeInstructions+= `${route[9]}, at ${route[2]} metres, for ${( (parseInt(route[4]/60)>0) ? parseInt(route[4]/60)+' minutes' : (route[4]+' seconds') )}.`;

                routeInstructions+= "</td>";
                routeInstructions+= "</tr>";
              }
              routeInstructions+= "</table>";
              // console.log(routeCounter);
              routes[routeCounter]["route_instructions"]=routeInstructions;
              routeCounter++;
            }

          }

          var addressPatterns={
            'Hl':'Hill',
            'Rd':'Road',
            'Dr':'Drive',
            'Jln':'Jalan',
            'Bt':'Bukit',
            'Ave':'Avenue',
            'Upp':'Upper'
          };

          function replaceAllStr(inputStr,searchStr,replaceStr) {
            let str=inputStr.split(searchStr).join(replaceStr);
            return str;
          }

          function renderHERERouteInstructions(responseObj) {
            let sections=responseObj['routes'][0]['sections'][0];

            let routeCounter=0;
            let routeInstructions = '';
            routeInstructions += '<table>';
            let route_instructions=sections['actions'];

            for(let r in route_instructions) {
              let route = route_instructions[r];
              let routeSeconds=parseInt(route['duration']);
              let distance_metres=parseInt(route['length']);

              let intrText=route['instruction'];

              let pattern = new RegExp(`. Go for ${distance_metres} m.`, 'g');
              intrText=intrText.replace(pattern, '');
              pattern = new RegExp(`. Go for ${(distance_metres/1000).toFixed(1)} km.`, 'g');
              intrText=intrText.replace(pattern, '');
              intrText=`${intrText},`;

              for(let toReplace in addressPatterns) {
                let replaceWith=addressPatterns[toReplace];

                intrText=replaceAllStr(intrText,  ` ${toReplace},`, ` ${replaceWith},`);
                intrText=replaceAllStr(intrText,  ` ${toReplace} `, ` ${replaceWith} `);
              }

              routeInstructions+= '<tr>';
              routeInstructions+= '<th valign="top" class="pr-2">' + parseInt(parseInt(r)+1) + '</th>';
              routeInstructions+= '<td>';
              routeInstructions+= `${intrText} at ${distance_metres} metres, for ${routeSeconds} seconds.`;
              routeInstructions+= '</td>';
              routeInstructions+= '</tr>';
            }
            routeInstructions+= '</table>';

            routes[routeCounter]['route_instructions']=routeInstructions;
            routeCounter++;

            document.getElementById('route_instructions').innerHTML=routeInstructions;
          }

          initParams(startPoint, endPoint);
          execAjax();

      }; // window.onload
    </script>
  </body>
</html>